/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "rtos.h"
#include <string.h>
#include <stdio.h>

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;
UART_HandleTypeDef huart2;
TIM_HandleTypeDef htim2;

/* ===================== Application Globals ===================== */

// ADC + sensor
volatile uint16_t adcRaw     = 0;
volatile float    current_A  = 0.0f;   // computed current
volatile float    voltage_V  = 0.0f;   // scaled ACS712 output

const float Vref   = 3.3f;
const float adcMax = 4095.0f;

// ACS712 20A: ~100 mV/A at 5V, scaled by 2/3 in divider -> ~66.7 mV/A
// Adjust after calibrating!
const float acs712_sensitivity = 0.0667f; // V per A (approx)

// Relay GPIO
#define RELAY_PORT GPIOB
#define RELAY1_PIN GPIO_PIN_0
#define RELAY2_PIN GPIO_PIN_1

volatile uint8_t relay1_state = 0;
volatile uint8_t relay2_state = 0;

// Command flags from ESP32 (set by UART RX callback)
volatile uint8_t cmd_L1_on  = 0;
volatile uint8_t cmd_L1_off = 0;
volatile uint8_t cmd_L2_on  = 0;
volatile uint8_t cmd_L2_off = 0;

// UART RX line buffer (for commands like "L1_ON\n")
#define RX_BUF_SIZE 64
uint8_t  rxByte;
char     rxLine[RX_BUF_SIZE];
uint8_t  rxIndex = 0;

/* ===================== Function Prototypes ===================== */

// These are generated by CubeMX in your project:
void SystemClock_Config(void);
void MX_GPIO_Init(void);
void MX_USART2_UART_Init(void);
void MX_ADC1_Init(void);
void MX_TIM2_Init(void);

// Our helpers:
void start_adc_sampling(void);
void start_uart_rx_it(void);

// RTOS tasks:
void SensorTask(void *param);
void ControlTask(void *param);
void UartTxTask(void *param);

/* ===================== HAL Callbacks ===================== */

// ADC conversion complete callback: called at 1 kHz via TIM2 trigger
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef *hadc)
{
    if (hadc->Instance == ADC1)
    {
        adcRaw = HAL_ADC_GetValue(&hadc1);
    }
}

// UART RX complete callback: line-based command parser
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if (huart->Instance == USART2)
    {
        if (rxByte == '\n' || rxByte == '\r')
        {
            if (rxIndex > 0)
            {
                rxLine[rxIndex] = '\0';

                if (strcmp(rxLine, "L1_ON") == 0)   { cmd_L1_on  = 1; }
                if (strcmp(rxLine, "L1_OFF") == 0)  { cmd_L1_off = 1; }
                if (strcmp(rxLine, "L2_ON") == 0)   { cmd_L2_on  = 1; }
                if (strcmp(rxLine, "L2_OFF") == 0)  { cmd_L2_off = 1; }
            }
            rxIndex = 0;
        }
        else
        {
            if (rxIndex < RX_BUF_SIZE - 1)
            {
                rxLine[rxIndex++] = (char)rxByte;
            }
        }

        // Re-arm reception of next byte
        HAL_UART_Receive_IT(&huart2, &rxByte, 1);
    }
}

/* ===================== Helper Functions ===================== */

// Start 1 kHz ADC sampling: TIM2 triggers ADC1 conversions with interrupt
void start_adc_sampling(void)
{
    HAL_TIM_Base_Start(&htim2);       // TIM2 configured at 1 kHz, TRGO=Update
    HAL_ADC_Start_IT(&hadc1);         // ADC1 external trigger, interrupt on complete
}

// Start UART2 interrupt-based RX (1 byte at a time)
void start_uart_rx_it(void)
{
    rxIndex = 0;
    HAL_UART_Receive_IT(&huart2, &rxByte, 1);
}

/* ===================== RTOS Tasks ===================== */

// 1) SensorTask: convert raw ADC to voltage & current
// Runs e.g. every 10 ms
void SensorTask(void *param)
{
    (void)param;

    // Convert ADC to voltage (after divider, 0..3.3V)
    voltage_V = (adcRaw * Vref) / adcMax;

    // ACS712 output is centered at ~Vref/2
    float sensor_offset = Vref / 2.0f;
    float deltaV = voltage_V - sensor_offset;

    // Convert delta voltage to current (approx)
    current_A = deltaV / acs712_sensitivity;
}

// 2) ControlTask: apply commands & automatic rules to relays
// Runs e.g. every 20 ms
void ControlTask(void *param)
{
    (void)param;

    // Apply commands from ESP32
    if (cmd_L1_on)  { relay1_state = 1; cmd_L1_on  = 0; }
    if (cmd_L1_off) { relay1_state = 0; cmd_L1_off = 0; }
    if (cmd_L2_on)  { relay2_state = 1; cmd_L2_on  = 0; }
    if (cmd_L2_off) { relay2_state = 0; cmd_L2_off = 0; }

    // Example automatic rule: if current > 5 A, force Relay 2 OFF
    if (current_A > 5.0f)
    {
        relay2_state = 0;
    }

    // Many relay boards are active-LOW: LOW = ON, HIGH = OFF.
    // Adjust if your module is active-HIGH.
    HAL_GPIO_WritePin(RELAY_PORT, RELAY1_PIN,
                      relay1_state ? GPIO_PIN_RESET : GPIO_PIN_SET);
    HAL_GPIO_WritePin(RELAY_PORT, RELAY2_PIN,
                      relay2_state ? GPIO_PIN_RESET : GPIO_PIN_SET);
}

// 3) UartTxTask: send JSON-ish line to ESP32
// Runs e.g. every 1000 ms
void UartTxTask(void *param)
{
    (void)param;
    char buf[96];

    // Build simple JSON line: {"I":1.234,"V":2.500,"R1":1,"R2":0}
    snprintf(buf, sizeof(buf),
             "{\"I\":%.3f,\"V\":%.3f,\"R1\":%d,\"R2\":%d}\n",
             current_A,
             voltage_V,
             relay1_state,
             relay2_state);

    HAL_UART_Transmit(&huart2, (uint8_t *)buf, strlen(buf), 100);
}

/* ===================== main() ===================== */

int main(void)
{
    /* MCU Configuration--------------------------------------------------------*/

    HAL_Init();
    SystemClock_Config();

    MX_GPIO_Init();
    MX_USART2_UART_Init();
    MX_ADC1_Init();
    MX_TIM2_Init();

    // Start ADC sampling and UART RX
    start_adc_sampling();
    start_uart_rx_it();

    // Initialize our cooperative RTOS with 1 ms tick
    RTOS_Init(1);   // 1ms SysTick

    // Add tasks:
    // SensorTask:  every 10 ms
    // ControlTask: every 20 ms
    // UartTxTask:  every 1000 ms
    RTOS_AddTask(SensorTask,  NULL, 10,   0);
    RTOS_AddTask(ControlTask, NULL, 20,   0);
    RTOS_AddTask(UartTxTask,  NULL, 1000, 0);

    /* Infinite loop */
    while (1)
    {
        RTOS_RunScheduler();
        // Optionally low-power:
        // __WFI();
    }
}

